# kWire

[![](https://git.karmakrafts.dev/kk/kwire/badges/master/pipeline.svg)](https://git.karmakrafts.dev/kk/kwire/-/pipelines)
[![](https://img.shields.io/maven-metadata/v?metadataUrl=https%3A%2F%2Frepo.maven.apache.org%2Fmaven2%2Fdev%2Fkarmakrafts%2Fkwire%2Fkwire-runtime%2Fmaven-metadata.xml
)](https://git.karmakrafts.dev/kk/kwire/-/packages)
[![](https://img.shields.io/maven-metadata/v?metadataUrl=https%3A%2F%2Fcentral.sonatype.com%2Frepository%2Fmaven-snapshots%2Fdev%2Fkarmakrafts%2Fkwire%2Fkwire-runtime%2Fmaven-metadata.xml
)](https://git.karmakrafts.dev/kk/kwire/-/packages)

Shared library access and FFI for Kotlin Multiplatform.  
**This library does not support JS/WASM targets, and there is no plans on supporting it in the future,
if you know how to do it, feel free to contribute :)**

## How it works

### Runtime

The kWire runtime provides a complete suite of FFI APIs for working with
shared libraries from Kotlin common code.

* On the JVM, the runtime implements/wraps around the Panama API available with Java 21+.  
  This allows easy interaction with platform-specific JVM code and a lot of opportunity for
  optimizations which directly tie into the JIT compiler

* On Android, the Panama API is not available out of the box.  
  For this reason, kWire uses a [port of Project Panama to Android](https://github.com/vova7878/PanamaPort) to substitute the 
  missing standard APIs

* On native targets, kWire uses a custom implementation built in Kotlin/Native and using
  [libffi](https://github.com/libffi/libffi) for dispatching calls at runtime in an efficient manner, giving very acceptable
  performance to builtin C-function calls in Kotlin/Native

### Compiler RT

The kWire compiler runtime (compiler-rt) provides a set of annotations which allows  
the platform specific compile-time optimization of calls made to native code.  
This is possible through special IR processing provided by the compiler plugin.


### Compiler Plugin

The compiler plugin is the actual meat of the compiler runtime.  
It implements all the target-specific optimizations described below  
by transforming and generating Kotlin IR code.

The main purpose of these optimizations is to avoid additional overhead for vararg-allocations  
and implicit boxing/unboxing of primitive values.

* On the JVM/Android, calls made using a `FFIFunction` instance, these calls get transformed
  from `MethodHandle.invokeWithArguments` to a specialized `MethodHandle.invokeExact` call.  
  This completely eliminates the overhead of implicit `Object...` array allocations and also
  any boxing/unboxing overhead for primitives. It also allows the JIT to inline the native
  function call into machine code once a hot path is determined.

* On native targets, `FFIFunction` calls get transformed so that the Kotlin/Native compiler
  backend will emit LLVM IR which directly invokes the native trampoline generated by Kotlin
  instead of going through libffi, which would otherwise introduce additional overhead (usually ~2x slower than a regular call)

### Gradle Plugin

The Gradle plugin simply exists to inject the compiler plugin into the Kotlin compiler (daemon),  
however it is planned to be extended with code generation capabilities similar to **kotlinx.cinterop**.